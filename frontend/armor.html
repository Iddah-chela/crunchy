<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Armor Game — Prototype (Shapes)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html,body { margin:0; padding:0; height:100%; background:#111; color:#fff; font-family: Arial, sans-serif; }
    #game-container { width:100%; height:100vh; overflow:hidden; }
    #hint { position: absolute; left:10px; bottom:6px; color:#ccc; font-size:12px; z-index: 10; }
    .jump-highlight { outline: 3px solid #ffff66; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
</head>
<body>
  <div id="game-container"></div>
  <div id="hint">Move: arrows / WASD (or touch buttons). Fire (sword): SPACE. Pray: E (or PRAY button).</div>

<script>
const WIDTH = 900;
const HEIGHT = 600;

const config = {
  type: Phaser.AUTO,
  parent: 'game-container',
  width: WIDTH,
  height: HEIGHT,
  backgroundColor: '#222',
  physics: { default: 'arcade', arcade: { debug: false } },
  scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);

function preload() {
  // No external assets needed. We're using shapes created at runtime.
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

function create() {
  const scene = this;
  scene.level = 1;
  scene.timeLeft = 300;
  scene.score = 0;

  scene.stats = { peace: 100, happiness: 100, joy: 100, truth: 100 };
  scene.getLife = () => {
    const {peace, happiness, joy, truth} = scene.stats;
    return clamp(Math.floor((peace + happiness + joy + truth) / 4), 0, 100);
  };

  scene.activeArmors = {};
  scene.swordAvailable = false;
  scene.swordUses = 0;
  scene.swordCooldown = false;

  this.cameras.main.setBackgroundColor('#222');

  // Physics groups
  scene.enemies = scene.physics.add.group();
  scene.armors = scene.physics.add.group();
  scene.beams = scene.physics.add.group();
  scene.prayers = scene.physics.add.staticGroup();

  // PLAYER - rectangle with physics
  scene.player = scene.add.rectangle(100, HEIGHT / 2, 32, 36, 0x66ff99);
  scene.physics.add.existing(scene.player);
  scene.player.body.setCollideWorldBounds(true);
  scene.player.body.setBounce(0);
  scene.player.setDepth(2);

  // Goal - tall rectangle static
  scene.goal = scene.add.rectangle(WIDTH - 60, HEIGHT / 2, 40, 260, 0xffffff);
  scene.physics.add.existing(scene.goal, true); // static body
  scene.goal.body.setSize(40,260);

  // Prayer spots - circles static
  const p1 = scene.add.circle(300, HEIGHT - 140, 24, 0xffffaa);
  const p2 = scene.add.circle(500, 120, 24, 0xffffaa);
  scene.physics.add.existing(p1, true); scene.physics.add.existing(p2, true);
  scene.prayers.add(p1); scene.prayers.add(p2);

  // UI
  scene.ui = {};
  scene.ui.levelText = scene.add.text(12, 8, 'Level: 1', { fontSize: '18px', fill: '#fff' }).setScrollFactor(0);
  scene.ui.timeText = scene.add.text(12, 28, 'Time: 300', { fontSize: '16px', fill: '#fff' }).setScrollFactor(0);

  const barX = 140, barY = 8, barW = 140, barH = 14, gap = 6;
  scene.ui.barLabels = [];
  scene.ui.barFills = [];
  const labels = ['Life', 'Peace', 'Happiness', 'Joy', 'Truth'];
  for (let i=0;i<labels.length;i++){
    const y = barY + i*(barH + gap);
    scene.ui.barLabels.push(scene.add.text(barX - 80, y - 2, labels[i], { fontSize: '13px', fill: '#fff' }).setScrollFactor(0));
    const bg = scene.add.rectangle(barX, y+6, barW, barH, 0x333333).setOrigin(0,0.5).setScrollFactor(0);
    const fill = scene.add.rectangle(barX, y+6, barW, barH, 0x66cc66).setOrigin(0,0.5).setScrollFactor(0);
    scene.ui.barFills.push(fill);
  }
  scene.ui.armorText = scene.add.text(12, 120, 'Armor: None', { fontSize: '14px', fill: '#fff' }).setScrollFactor(0);
  scene.ui.swordText = scene.add.text(12, 140, 'Sword: None', { fontSize: '14px', fill: '#fff' }).setScrollFactor(0);
  scene.ui.bottomExplain = scene.add.text(12, HEIGHT - 36, '', { fontSize: '16px', fill: '#ffffcc' }).setScrollFactor(0);

  scene._explainTimer = null;

  // Input
  scene.cursors = scene.input.keyboard.createCursorKeys();
  scene.keys = scene.input.keyboard.addKeys({ W: Phaser.Input.Keyboard.KeyCodes.W, A: Phaser.Input.Keyboard.KeyCodes.A, S: Phaser.Input.Keyboard.KeyCodes.S, D: Phaser.Input.Keyboard.KeyCodes.D, SPACE: Phaser.Input.Keyboard.KeyCodes.SPACE, E: Phaser.Input.Keyboard.KeyCodes.E });

  scene.moveLeft = scene.moveRight = scene.moveUp = scene.moveDown = false;

  // Colliders / overlaps
  scene.physics.add.overlap(scene.player, scene.enemies, onPlayerHitEnemy, null, scene);
  scene.physics.add.overlap(scene.player, scene.armors, onPickupArmor, null, scene);
  scene.physics.add.overlap(scene.beams, scene.enemies, onBeamHitEnemy, null, scene);
  scene.physics.add.overlap(scene.player, scene.goal, onReachGoal, null, scene);
  scene.physics.add.overlap(scene.player, scene.prayers, onAtPrayerSpot, null, scene);

  // Start spawns
  scene.spawnEvent = null;
  startLevel(scene, scene.level);

  scene.time.addEvent({ delay: 7000, loop: true, callback: () => spawnArmor(scene) });
  scene.time.addEvent({ delay: 1000, loop: true, callback: () => { scene.timeLeft--; scene.ui.timeText.setText('Time: ' + scene.timeLeft); if (scene.timeLeft <= 0) endGame(scene);} });

  scene.isMobile = this.sys.game.device.os.android || this.sys.game.device.os.iOS || window.innerWidth < 700;
  if (scene.isMobile) createMobileControls(scene);

  scene.events.on('update', ()=> updateUIBars(scene));
  updateUIBars(scene);

  // FUNCTION IMPLEMENTATIONS (closures use scene)
  function onPlayerHitEnemy(player, enemy) {
    if (!enemy.active) return;
    const mapping = enemyTypeToStat(enemy.enemyType);
    const protects = Object.values(scene.activeArmors).some(a => a && a.protects && a.protects.includes(mapping.stat));
    if (protects) { enemy.destroy(); showBottomText(scene, `Your armor protected you from ${enemy.enemyType}!`); return; }
    const stat = mapping.stat; const damage = mapping.damage;
    scene.stats[stat] = clamp(scene.stats[stat] - damage, 0, 100);
    showBottomText(scene, `${enemy.enemyType} hit! -${damage} ${capitalize(stat)}`);
    enemy.destroy();
    if (scene.getLife() <= 0) endGame(scene);
  }

  function onBeamHitEnemy(beam, enemy) { if (enemy.active) { enemy.destroy(); scene.score += 1; } }

  function onPickupArmor(player, armor) {
    if (!armor.active) return;
    const type = armor.pickType; armor.destroy();
    if (type === 'sword') {
      scene.swordAvailable = true; scene.swordUses += 1;
      scene.ui.swordText.setText('Sword: READY (uses: ' + scene.swordUses + ')');
      showBottomText(scene, 'Sword of the Spirit collected! Press SPACE or FIRE to use it.');
      return;
    }
    const def = armorDefinitions[type]; if (!def) return;
    const now = scene.time.now; const expires = now + def.duration * 1000;
    scene.activeArmors[type] = { expiresAt: expires, protects: def.protects, label: def.label };
    showBottomText(scene, def.label);
    updateArmorUI(scene);
  }

  function onReachGoal(player, goal) {
    scene.level++; scene.ui.levelText.setText('Level: ' + scene.level);
    showBottomText(scene, 'Level complete! Starting Level ' + scene.level);
    scene.enemies.clear(true, true); scene.armors.clear(true, true);
    scene.player.setPosition(100, HEIGHT/2);
    startLevel(scene, scene.level);
  }

  function onAtPrayerSpot() { showBottomText(scene, 'Press E (or PRAY) to receive +stat here.'); }

  function spawnEnemy(scene, x, y, enemyType) {
    const colorMap = { lie: 0xff4444, fear: 0x4477ff, doubt: 0x44ff99, hate: 0xffaa33 };
    const size = 36;
    const e = scene.add.rectangle(x, y, size, size, colorMap[enemyType] || 0xffffff);
    scene.physics.add.existing(e);
    e.enemyType = enemyType; e.speed = enemyTypeProps(enemyType).speed;
    e.body.setSize(size - 6, size - 6); // smaller hitbox
    e.setDepth(1);
    scene.enemies.add(e);
    return e;
  }

  function spawnWave(scene, count) {
    const spawnMargin = 30;
    for (let i=0;i<count;i++){
      const side = Phaser.Math.Between(0,3);
      let x=0, y=0;
      if (side===0) { x = Phaser.Math.Between(spawnMargin, WIDTH - spawnMargin); y = -40; }
      else if (side===1) { x = Phaser.Math.Between(spawnMargin, WIDTH - spawnMargin); y = HEIGHT + 40; }
      else if (side===2) { x = -40; y = Phaser.Math.Between(spawnMargin, HEIGHT - spawnMargin); }
      else { x = WIDTH + 40; y = Phaser.Math.Between(spawnMargin, HEIGHT - spawnMargin); }
      const types = pickEnemyTypesForLevel(scene.level);
      const type = types[Phaser.Math.Between(0, types.length-1)];
      spawnEnemy(scene, x, y, type);
    }
  }

  function pickEnemyTypesForLevel(level) {
    const base = ['lie','fear'];
    if (level >= 2) base.push('doubt');
    if (level >= 3) base.push('hate');
    return base;
  }

  function startLevel(scene, level) {
    if (scene.spawnEvent) scene.spawnEvent.remove();
    const delay = Math.max(900 - (level * 30), 300);
    scene.spawnEvent = scene.time.addEvent({ delay, loop: true, callback: () => { const waveSize = 1 + Math.floor(level / 1.2); spawnWave(scene, waveSize); } });
  }

  function spawnArmor(scene) {
    const types = ['truth','peace','joy','happy','sword'];
    const type = types[Phaser.Math.Between(0, types.length-1)];
    const x = Phaser.Math.Between(150, WIDTH - 200);
    const y = Phaser.Math.Between(80, HEIGHT - 80);
    const colorMap = { truth: 0xffff66, peace: 0x66ccff, joy: 0xff66ff, happiness: 0x88ff88, sword: 0xffffff };
    const keyType = (type === 'happy') ? 'happiness' : (type === 'sword' ? 'sword' : type);
    const a = scene.add.circle(x, y, 12, colorMap[keyType] || 0xffffff);
    scene.physics.add.existing(a);
    a.setDepth(1);
    a.pickType = keyType;
    scene.armors.add(a);
  }

  const armorDefinitions = {
    truth: { protects: ['truth'], duration: 10, label: 'Helmet of Truth — protects Truth stat for 10s' },
    peace: { protects: ['peace'], duration: 10, label: 'Shield of Peace — protects Peace stat for 10s' },
    joy:   { protects: ['joy'], duration: 10, label: 'Boots of Joy — protects Joy stat for 10s' },
    happiness: { protects: ['happiness'], duration: 10, label: 'Breastplate of Happiness — protects Happiness for 10s' }
  };

  function enemyTypeToStat(t) { switch(t){ case 'lie': return { stat: 'truth', damage: 18 }; case 'fear': return { stat: 'peace', damage: 12 }; case 'doubt': return { stat: 'joy', damage: 14 }; case 'hate': return { stat: 'happiness', damage: 20 }; default: return { stat: 'peace', damage: 10 }; } }
  function enemyTypeProps(t) { switch(t){ case 'lie': return { speed: 60 }; case 'fear': return { speed: 90 }; case 'doubt': return { speed: 45 }; case 'hate': return { speed: 75 }; default: return { speed: 60 }; } }
  function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }
  function showBottomText(scene, text, duration=3000) { scene.ui.bottomExplain.setText(text); if (scene._explainTimer) scene._explainTimer.remove(); scene._explainTimer = scene.time.delayedCall(duration, ()=> scene.ui.bottomExplain.setText('')); }

  function endGame(scene) {
    scene.spawnEvent && scene.spawnEvent.remove();
    scene.enemies.clear(true, true); scene.armors.clear(true, true); scene.beams.clear(true, true);
    scene.add.rectangle(WIDTH/2, HEIGHT/2, 520, 260, 0x000000, 0.75).setOrigin(0.5,0.5).setDepth(10);
    scene.add.text(WIDTH/2 - 120, HEIGHT/2 - 50, '⏰ Time or Life ended!', { fontSize: '30px', fill: '#fff' }).setDepth(10);
    scene.add.text(WIDTH/2 - 120, HEIGHT/2 - 10, 'Levels Cleared: ' + (scene.level - 1), { fontSize: '22px', fill: '#fff' }).setDepth(10);
    scene.add.text(WIDTH/2 - 120, HEIGHT/2 + 30, 'Press SPACE to restart', { fontSize: '18px', fill: '#fff' }).setDepth(10);
    scene.input.keyboard.once('keydown-SPACE', ()=> { scene.scene.restart(); });
  }

  function updateArmorUI(scene) {
    const keys = Object.keys(scene.activeArmors).filter(k=>scene.activeArmors[k] && scene.activeArmors[k].expiresAt > scene.time.now);
    if (keys.length === 0) scene.ui.armorText.setText('Armor: None');
    else scene.ui.armorText.setText('Armor: ' + keys.map(k => scene.activeArmors[k].label || k).join(', '));
  }

  function createMobileControls(scene) {
    const size = 54, y = HEIGHT - size - 8;
    const left = scene.add.rectangle(64, y, size, size, 0x444444).setInteractive().setDepth(20);
    const right = scene.add.rectangle(64 + (size+8)*1, y, size, size, 0x444444).setInteractive().setDepth(20);
    const up = scene.add.rectangle(WIDTH - 160, y - 48, size, size, 0x444444).setInteractive().setDepth(20);
    const down = scene.add.rectangle(WIDTH - 160, y + 48, size, size, 0x444444).setInteractive().setDepth(20);
    const fire = scene.add.rectangle(WIDTH - 64, y, size, size, 0x444444).setInteractive().setDepth(20);
    const pray = scene.add.rectangle(WIDTH - 64, y - 120, size, size, 0x444444).setInteractive().setDepth(20);

    scene.add.text(40, y-6, 'L', { fontSize: '20px' }).setDepth(21);
    scene.add.text(94, y-6, 'R', { fontSize: '20px' }).setDepth(21);
    scene.add.text(WIDTH - 176, y - 54, 'U', { fontSize: '20px' }).setDepth(21);
    scene.add.text(WIDTH - 176, y + 36, 'D', { fontSize: '20px' }).setDepth(21);
    scene.add.text(WIDTH - 84, y-6, 'FIRE', { fontSize: '12px' }).setDepth(21);
    scene.add.text(WIDTH - 84, y - 126, 'PRAY', { fontSize: '12px' }).setDepth(21);

    left.on('pointerdown', ()=> scene.moveLeft = true); left.on('pointerup', ()=> scene.moveLeft = false); left.on('pointerout', ()=> scene.moveLeft = false);
    right.on('pointerdown', ()=> scene.moveRight = true); right.on('pointerup', ()=> scene.moveRight = false); right.on('pointerout', ()=> scene.moveRight = false);
    up.on('pointerdown', ()=> scene.moveUp = true); up.on('pointerup', ()=> scene.moveUp = false); up.on('pointerout', ()=> scene.moveUp = false);
    down.on('pointerdown', ()=> scene.moveDown = true); down.on('pointerup', ()=> scene.moveDown = false); down.on('pointerout', ()=> scene.moveDown = false);
    fire.on('pointerdown', ()=> { if (scene.swordAvailable) fireSword(scene); });
    pray.on('pointerdown', ()=> attemptPray(scene));
  }

  function attemptPray(scene){
    let nearPrayer = false;
    scene.prayers.getChildren().forEach(p => {
      if (Phaser.Geom.Intersects.RectangleToRectangle(scene.player.getBounds(), p.getBounds())) nearPrayer = true;
    });
    if (!nearPrayer) { showBottomText(scene, 'Find a Prayer Spot to pray here'); return; }
    let lowest = 'peace'; let minVal = scene.stats[lowest];
    ['happiness','joy','truth','peace'].forEach(s=>{ if (scene.stats[s] < minVal) { minVal = scene.stats[s]; lowest = s; }});
    scene.stats[lowest] = clamp(scene.stats[lowest] + 12, 0, 100);
    showBottomText(scene, `You prayed and gained +12 ${capitalize(lowest)}`);
  }

  function fireSword(scene) {
    if (!scene.swordAvailable) return;
    if (scene.swordCooldown) return;
    if (scene.swordUses <= 0) return;
    const b = scene.add.rectangle(scene.player.x + 20, scene.player.y, 20, 8, 0xffffff);
    scene.physics.add.existing(b);
    b.body.allowGravity = false;
    b.body.setVelocityX(600);
    scene.beams.add(b);
    scene.swordUses--;
    scene.ui.swordText.setText('Sword: READY (uses: ' + scene.swordUses + ')');
    scene.swordCooldown = true;
    scene.time.delayedCall(600, ()=> scene.swordCooldown = false);
    if (scene.swordUses <= 0) { scene.swordAvailable = false; scene.time.delayedCall(500, ()=> scene.ui.swordText.setText('Sword: None')); }
  }

  function updateUIBars(scene) {
    const life = scene.getLife();
    const values = [ life, scene.stats.peace, scene.stats.happiness, scene.stats.joy, scene.stats.truth ];
    const colors = [0xff6666, 0x66ccff, 0xffcc66, 0xff66ff, 0xffff66];
    for (let i=0;i<scene.ui.barFills.length;i++){
      const fill = scene.ui.barFills[i]; const val = values[i]; const fullW = 140;
      fill.width = fullW * (val / 100); fill.setFillStyle(colors[i]);
    }
    updateArmorUI(scene);
    const now = scene.time.now;
    Object.keys(scene.activeArmors).forEach(k=>{ const a = scene.activeArmors[k]; if (a && a.expiresAt && a.expiresAt <= now) { delete scene.activeArmors[k]; showBottomText(scene, `${a.label} expired`); }});
  }

} // create ends

function update(time, delta) {
  const scene = this;
  const speed = 160;
  let vx = 0, vy = 0;
  if (scene.cursors.left.isDown || scene.keys.A.isDown) vx -= speed;
  if (scene.cursors.right.isDown || scene.keys.D.isDown) vx += speed;
  if (scene.cursors.up.isDown || scene.keys.W.isDown) vy -= speed;
  if (scene.cursors.down.isDown || scene.keys.S.isDown) vy += speed;
  if (scene.moveLeft) vx = -speed; if (scene.moveRight) vx = speed; if (scene.moveUp) vy = -speed; if (scene.moveDown) vy = speed;
  scene.player.body.setVelocity(vx, vy);
  if (Phaser.Input.Keyboard.JustDown(scene.keys.SPACE)) { if (scene.swordAvailable) fireSword(scene); }
  if (Phaser.Input.Keyboard.JustDown(scene.keys.E)) { attemptPray(scene); }
  scene.enemies.getChildren().forEach(e => { if (!e.active) return; scene.physics.moveToObject(e, scene.player, e.speed); });
  updateActiveArmorDurations(scene);
}

// helper functions referenced in update() scope but declared after
function updateActiveArmorDurations(scene) {
  const now = scene.time.now;
  const active = Object.keys(scene.activeArmors);
  if (active.length === 0) return;
  const parts = active.map(k=>{ const ar = scene.activeArmors[k]; const remain = Math.max(0, Math.floor((ar.expiresAt - now)/1000)); return `${ar.label} (${remain}s)`; });
  scene.ui.armorText.setText('Armor: ' + parts.join(' | '));
}

// small helpers used by closures
function enemyTypeToStatExternal(t) {
  switch(t) { case 'lie': return { stat: 'truth', damage: 18 }; case 'fear': return { stat: 'peace', damage: 12 }; case 'doubt': return { stat: 'joy', damage: 14 }; case 'hate': return { stat: 'happiness', damage: 20 }; default: return { stat: 'peace', damage: 10 }; 

  }}
</script>
</body>
</html>
